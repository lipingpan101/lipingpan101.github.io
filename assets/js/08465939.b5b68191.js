"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2281],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>d});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=o.createContext({}),c=function(e){var t=o.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return o.createElement(u.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,u=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),p=c(n),f=a,d=p["".concat(u,".").concat(f)]||p[f]||h[f]||r;return n?o.createElement(d,s(s({ref:t},l),{},{components:n})):o.createElement(d,s({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=f;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i[p]="string"==typeof e?e:a,s[1]=i;for(var c=2;c<r;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},443:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const r={title:"React Hooks"},s=void 0,i={permalink:"/blog/2023/02/23/react-hooks",editUrl:"https://lipingpan101.github.io/blog/2023-02-23-react-hooks.md",source:"@site/blog/2023-02-23-react-hooks.md",title:"React Hooks",description:"Introduction",date:"2023-02-23T00:00:00.000Z",formattedDate:"February 23, 2023",tags:[],readingTime:4.415,hasTruncateMarker:!1,authors:[],frontMatter:{title:"React Hooks"},prevItem:{title:"TDD Benefits for Beginners",permalink:"/blog/2023/02/23/TDD-benefits"}},u={authorsImageUrls:[]},c=[{value:"Introduction",id:"introduction",level:2},{value:"What are React Hooks?",id:"what-are-react-hooks",level:2},{value:"The useState Hook",id:"the-usestate-hook",level:2},{value:"The useEffect Hook",id:"the-useeffect-hook",level:2},{value:"Custom Hooks",id:"custom-hooks",level:2},{value:"Best Practices for Using React Hooks",id:"best-practices-for-using-react-hooks",level:2},{value:"Conclusion",id:"conclusion",level:2}],l={toc:c},p="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,o.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"React Hooks were introduced in version 16.8 of React and have become a popular feature among developers. Hooks provide a way to manage state and side effects in functional components, making them more powerful and easier to write. In this article, we'll explore the basics of React Hooks and how to use them to manage state and side effects in your applications."),(0,a.kt)("h2",{id:"what-are-react-hooks"},"What are React Hooks?"),(0,a.kt)("p",null,"React Hooks are functions that allow you to use state and other React features in functional components. They provide a way to reuse stateful logic between components, without having to create class components or pass props down through many levels of components. There are several built-in hooks that come with React, such as useState and useEffect, and you can also create your own custom hooks."),(0,a.kt)("h2",{id:"the-usestate-hook"},"The useState Hook"),(0,a.kt)("p",null,"The useState hook allows you to manage state in functional components. It takes an initial state value and returns an array with the current state value and a function to update that state value. You can use multiple instances of the useState hook to manage different pieces of state in your component."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={handleClick}>\n        Click me\n      </button>\n    </div>\n  );\n}\n")),(0,a.kt)("p",null,"In this example, we are using the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," hook to manage state in a functional component. We initialize the state with a value of ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),", and we get back an array with the current state value (",(0,a.kt)("inlineCode",{parentName:"p"},"count"),") and a function to update that state value (",(0,a.kt)("inlineCode",{parentName:"p"},"setCount"),"). When the button is clicked, we call the ",(0,a.kt)("inlineCode",{parentName:"p"},"handleClick")," function, which updates the state by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"setCount")," with the new value of ",(0,a.kt)("inlineCode",{parentName:"p"},"count + 1"),"."),(0,a.kt)("h2",{id:"the-useeffect-hook"},"The useEffect Hook"),(0,a.kt)("p",null,"The useEffect hook allows you to manage side effects in functional components. It takes a function that performs a side effect, such as fetching data or updating the DOM, and an array of dependencies that trigger the effect when they change. You can use multiple instances of the useEffect hook to manage different side effects in your component."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javas"},"import React, { useState, useEffect } from 'react';\n\nfunction UserList() {\n  const [users, setUsers] = useState([]);\n\n  useEffect(() => {\n    fetch('https://jsonplaceholder.typicode.com/users')\n      .then(response => response.json())\n      .then(data => setUsers(data));\n  }, []);\n\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n")),(0,a.kt)("p",null,"In this example, we are using the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hook to fetch data from an API and update the state in a functional component. We initialize the state with an empty array, and we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hook to perform the fetch operation when the component mounts (i.e., when the array of dependencies is empty). When the fetch operation is complete, we update the state by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"setUsers")," with the fetched data. Finally, we render the list of users by mapping over the ",(0,a.kt)("inlineCode",{parentName:"p"},"users")," array."),(0,a.kt)("h2",{id:"custom-hooks"},"Custom Hooks"),(0,a.kt)("p",null,"Custom hooks are functions that allow you to reuse stateful logic between components. They are a way to extract common functionality into a reusable module, making your code more modular and easier to maintain. Custom hooks can use built-in hooks or other custom hooks, and can take arguments and return values."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascrip"},"import React, { useState, useEffect } from 'react';\n\nfunction useCounter(initialCount) {\n  const [count, setCount] = useState(initialCount);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount(count => count + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return count;\n}\n\nfunction Timer() {\n  const count = useCounter(0);\n\n  return (\n    <p>You have been on this page for {count} seconds.</p>\n  );\n}\n")),(0,a.kt)("p",null,"In this example, we are creating a custom hook called ",(0,a.kt)("inlineCode",{parentName:"p"},"useCounter")," that uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hooks to implement a simple counter. The ",(0,a.kt)("inlineCode",{parentName:"p"},"useCounter")," hook takes an ",(0,a.kt)("inlineCode",{parentName:"p"},"initialCount")," argument and returns the current count value, which is updated every second using a ",(0,a.kt)("inlineCode",{parentName:"p"},"setInterval")," function inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hook. We then use the ",(0,a.kt)("inlineCode",{parentName:"p"},"useCounter")," hook inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"Timer")," component to display the number of seconds the user has been on the page."),(0,a.kt)("h2",{id:"best-practices-for-using-react-hooks"},"Best Practices for Using React Hooks"),(0,a.kt)("p",null,"To get the most out of React Hooks, it's important to follow some best practices. These include using the useState hook to manage local state, using the useEffect hook to manage side effects, and creating custom hooks to reuse stateful logic. It's also important to avoid using hooks inside loops or conditionals, and to use the array destructuring syntax to name your variables."),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"React Hooks are a powerful tool for managing state and side effects in your functional components. They allow you to reuse stateful logic between components, making your code more modular and easier to maintain. By following the best practices outlined in this article, you can take advantage of the full power of React Hooks and build better React applications."),(0,a.kt)("p",null,"React Hooks provide a way to manage state and side effects in functional components, making them more powerful and easier to write. By using the useState and useEffect hooks, creating custom hooks, and following best practices, you can take advantage of the full power of React Hooks and build better React applications. With this knowledge, you'll be able to take your front-end development skills to the next level and create more efficient and maintainable code."))}h.isMDXComponent=!0}}]);