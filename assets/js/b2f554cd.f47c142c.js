"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/02/23/TDD-benefits","metadata":{"permalink":"/blog/2023/02/23/TDD-benefits","editUrl":"https://lipingpan101.github.io/blog/2023-02-23-TDD-benefits.md","source":"@site/blog/2023-02-23-TDD-benefits.md","title":"TDD Benefits for Beginners","description":"Test-Driven Development (TDD) is an approach to software development that involves writing tests before writing code. By writing tests first, developers can ensure that their code is working as expected, and they can catch bugs early in the development process. TDD can be especially beneficial for beginners, as it can help them to break down tasks into smaller, more manageable chunks, and to focus on writing clean, maintainable code.","date":"2023-02-23T00:00:00.000Z","formattedDate":"February 23, 2023","tags":[],"readingTime":4.19,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"TDD Benefits for Beginners"},"nextItem":{"title":"Git Basics","permalink":"/blog/2023/02/23/git-basics"}},"content":"Test-Driven Development (TDD) is an approach to software development that involves writing tests before writing code. By writing tests first, developers can ensure that their code is working as expected, and they can catch bugs early in the development process. TDD can be especially beneficial for beginners, as it can help them to break down tasks into smaller, more manageable chunks, and to focus on writing clean, maintainable code.\\n\\nOne of the key benefits of TDD is that it helps developers to write better code by forcing them to think about the functionality of their code before they write it. This is especially important for beginners who may not have as much experience in writing code. When writing tests first, developers must break down the functionality of their code into smaller, testable units, which can help to make the task of writing code more manageable. This process of breaking down tasks into smaller units is known as \\"tasking\\", and it\'s a key part of TDD.\\n\\nTo illustrate the benefits of TDD, let\'s look at an example of a React component. Suppose we want to create a registration form for a website that allows users to sign up for an account. Here\'s how we could use TDD to write this feature:\\n\\n1. First, we write a test that checks that the registration form contains all the necessary fields:\\n\\n   ```javascript\\n   test(\'registration form contains required fields\', () => {\\n       const { getByLabelText } = render(<RegistrationForm />);\\n       expect(getByLabelText(/username/i)).toBeInTheDocument();\\n       expect(getByLabelText(/email/i)).toBeInTheDocument();\\n       expect(getByLabelText(/password/i)).toBeInTheDocument();\\n       expect(getByLabelText(/confirm password/i)).toBeInTheDocument();\\n   });\\n   ```\\n\\n2. Next, we write a test that checks that the form cannot be submitted if any of the fields are empty:\\n\\n   ```javascript\\n   test(\'form cannot be submitted if fields are empty\', () => {\\n       const { getByLabelText, getByRole } = render(<RegistrationForm />);\\n       fireEvent.click(getByRole(\'button\'));\\n   \\n       expect(getByLabelText(/username/i)).toHaveAttribute(\'required\');\\n       expect(getByLabelText(/email/i)).toHaveAttribute(\'required\');\\n       expect(getByLabelText(/password/i)).toHaveAttribute(\'required\');\\n       expect(getByLabelText(/confirm password/i)).toHaveAttribute(\'required\');\\n   });\\n   ```\\n\\n3. Then, we write a test that checks that the form cannot be submitted if the passwords don\'t match:\\n\\n   ```javascript\\n   test(\'form cannot be submitted if passwords do not match\', () => {\\n       const { getByLabelText, getByRole } = render(<RegistrationForm />);\\n       const usernameField = getByLabelText(/username/i);\\n       const emailField = getByLabelText(/email/i);\\n       const passwordField = getByLabelText(/password/i);\\n       const confirmPasswordField = getByLabelText(/confirm password/i);\\n   \\n       fireEvent.change(usernameField, { target: { value: \'testuser\' } });\\n       fireEvent.change(emailField, { target: { value: \'testuser@example.com\' } });\\n       fireEvent.change(passwordField, { target: { value: \'password\' } });\\n       fireEvent.change(confirmPasswordField, { target: { value: \'not the same password\' } });\\n   \\n       fireEvent.click(getByRole(\'button\'));\\n   \\n       expect(getByLabelText(/password/i)).toHaveAttribute(\'aria-invalid\', \'true\');\\n       expect(getByLabelText(/confirm password/i)).toHaveAttribute(\'aria-invalid\', \'true\');\\n   });\\n   ```\\n\\n4. Finally, we write a test that checks that the form can be submitted if all fields are filled out correctly:\\n\\n   ```javascript\\n   test(\'form can be submitted if all fields are filled out correctly\', () => {\\n     const { getByLabelText, getByRole } = render(<RegistrationForm />);\\n     const usernameField = getByLabelText(/username/i);\\n     const emailField = getByLabelText(/email/i);\\n     const passwordField = getByLabelText(/password/i);\\n     const confirmPasswordField = getByLabelText(/confirm password/i);\\n     \\n     fireEvent.change(usernameField, { target: { value: \'testuser\' } });\\n     fireEvent.change(emailField, { target: { value: \'testuser@example.com\' } });\\n     fireEvent.change(passwordField, { target: { value: \'password\' } });\\n     fireEvent.change(confirmPasswordField, { target: { value: \'password\' } });\\n   \\n     fireEvent.click(getByRole(\'button\'));\\n   \\n     expect(getByLabelText(/success message/i)).toBeInTheDocument();\\n   });\\n   ```\\n\\n5. Once all tests are passing, we can implement the code for the RegistrationForm component:\\n\\n   ```javascript\\n   import React from \'react\';\\n   \\n   function RegistrationForm(props) {\\n     const [formData, setFormData] = React.useState({\\n       username: \'\',\\n       email: \'\',\\n       password: \'\',\\n       confirmPassword: \'\'\\n     });\\n     const [formError, setFormError] = React.useState(\'\');\\n   \\n     function handleChange(event) {\\n       const { name, value } = event.target;\\n       setFormData(formData => ({\\n         ...formData,\\n         [name]: value\\n       }));\\n     }\\n   \\n   function handleSubmit(event) {\\n       event.preventDefault();\\n       if (formData.password !== formData.confirmPassword) {\\n         setFormError(\'Passwords do not match\');\\n       } else {\\n         // Call API to submit registration form data\\n         // If successful, display success message\\n       }\\n     }\\n     \\n       return (\\n       <form onSubmit={handleSubmit}>\\n         <div>\\n           <label htmlFor=\\"username\\">Username</label>\\n           <input\\n             type=\\"text\\"\\n             id=\\"username\\"\\n             name=\\"username\\"\\n             value={formData.username}\\n             onChange={handleChange}\\n             required\\n           />\\n         </div>\\n         <div>\\n           <label htmlFor=\\"email\\">Email</label>\\n           <input\\n             type=\\"email\\"\\n             id=\\"email\\"\\n             name=\\"email\\"\\n             value={formData.email}\\n             onChange={handleChange}\\n             required\\n           />\\n         </div>\\n         <div>\\n           <label htmlFor=\\"password\\">Password</label>\\n           <input\\n             type=\\"password\\"\\n             id=\\"password\\"\\n             name=\\"password\\"\\n             value={formData.password}\\n             onChange={handleChange}\\n             required\\n           />\\n         </div>\\n         <div>\\n           <label htmlFor=\\"confirmPassword\\">Confirm Password</label>\\n           <input\\n             type=\\"password\\"\\n             id=\\"confirmPassword\\"\\n             name=\\"confirmPassword\\"\\n             value={formData.confirmPassword}\\n             onChange={handleChange}\\n             required\\n           />\\n         </div>\\n         {formError && <div className=\\"error\\">{formError}</div>}\\n         <button type=\\"submit\\">Submit</button>\\n       </form>\\n     );\\n   }\\n   ```\\n\\nHere, we\'ve implemented a RegistrationForm component that uses the formData state to track the user\'s input, and the formError state to display an error message if the passwords don\'t match. The handleChange function updates the formData state whenever the user enters or modifies a value, and the handleSubmit function checks whether the passwords match before submitting the form.\\n\\nBy using TDD to write this feature, we were able to break down the task of creating a registration form into smaller, testable pieces, and we were able to ensure that each piece of code worked correctly before moving on to the next one. This approach helped us write code that was more modular, more maintainable, and less error-prone, which can be especially helpful for beginners who may not have as much experience with writing code.\\n\\nIn summary, Test-Driven Development can be a valuable tool for beginners to break down tasks into smaller, testable units, and to focus on writing clean, maintainable code. By using TDD, beginners can ensure that their code is working as expected, catch bugs early in the development process, and ultimately become better developers."},{"id":"/2023/02/23/git-basics","metadata":{"permalink":"/blog/2023/02/23/git-basics","editUrl":"https://lipingpan101.github.io/blog/2023-02-23-git-basics.md","source":"@site/blog/2023-02-23-git-basics.md","title":"Git Basics","description":"Here are some commonly used Git commands for working with remote repositories:","date":"2023-02-23T00:00:00.000Z","formattedDate":"February 23, 2023","tags":[],"readingTime":0.96,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Git Basics"},"prevItem":{"title":"TDD Benefits for Beginners","permalink":"/blog/2023/02/23/TDD-benefits"},"nextItem":{"title":"React Hooks","permalink":"/blog/2023/02/23/react-hooks"}},"content":"Here are some commonly used Git commands for working with remote repositories:\\n\\n1. `git clone`: This command is used to create a copy of a remote repository on your local machine.\\n2. `git remote`: This command is used to view the list of remote repositories that you have configured. To view the list of remote repositories, you can use the following command: `git remote -v`.\\n3. `git fetch`: This command is used to download changes from the remote repository, but it doesn\'t integrate them into your local repository.\\n4. `git pull`: This command is used to download changes from the remote repository and integrate them into your local repository.\\n5. `git push`: This command is used to upload changes from your local repository to the remote repository.\\n6. `git branch -r`: This command is used to list all the remote branches of a repository.\\n7. `git checkout -b branchname origin/branchname`: This command is used to create a new local branch from a remote branch.\\n8. `git merge`: This command is used to merge a branch into another branch.\\n9. `git remote add`: This command is used to add a new remote repository."},{"id":"/2023/02/23/react-hooks","metadata":{"permalink":"/blog/2023/02/23/react-hooks","editUrl":"https://lipingpan101.github.io/blog/2023-02-23-react-hooks.md","source":"@site/blog/2023-02-23-react-hooks.md","title":"React Hooks","description":"Introduction","date":"2023-02-23T00:00:00.000Z","formattedDate":"February 23, 2023","tags":[],"readingTime":4.415,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"React Hooks"},"prevItem":{"title":"Git Basics","permalink":"/blog/2023/02/23/git-basics"}},"content":"## Introduction\\n\\nReact Hooks were introduced in version 16.8 of React and have become a popular feature among developers. Hooks provide a way to manage state and side effects in functional components, making them more powerful and easier to write. In this article, we\'ll explore the basics of React Hooks and how to use them to manage state and side effects in your applications.\\n\\n## What are React Hooks?\\n\\nReact Hooks are functions that allow you to use state and other React features in functional components. They provide a way to reuse stateful logic between components, without having to create class components or pass props down through many levels of components. There are several built-in hooks that come with React, such as useState and useEffect, and you can also create your own custom hooks.\\n\\n## The useState Hook\\n\\nThe useState hook allows you to manage state in functional components. It takes an initial state value and returns an array with the current state value and a function to update that state value. You can use multiple instances of the useState hook to manage different pieces of state in your component.\\n\\n```javascript\\nimport React, { useState } from \'react\';\\n\\nfunction Counter() {\\n  const [count, setCount] = useState(0);\\n\\n  function handleClick() {\\n    setCount(count + 1);\\n  }\\n\\n  return (\\n    <div>\\n      <p>You clicked {count} times</p>\\n      <button onClick={handleClick}>\\n        Click me\\n      </button>\\n    </div>\\n  );\\n}\\n```\\n\\nIn this example, we are using the `useState` hook to manage state in a functional component. We initialize the state with a value of `0`, and we get back an array with the current state value (`count`) and a function to update that state value (`setCount`). When the button is clicked, we call the `handleClick` function, which updates the state by calling `setCount` with the new value of `count + 1`.\\n\\n## The useEffect Hook\\n\\nThe useEffect hook allows you to manage side effects in functional components. It takes a function that performs a side effect, such as fetching data or updating the DOM, and an array of dependencies that trigger the effect when they change. You can use multiple instances of the useEffect hook to manage different side effects in your component.\\n\\n```javas\\nimport React, { useState, useEffect } from \'react\';\\n\\nfunction UserList() {\\n  const [users, setUsers] = useState([]);\\n\\n  useEffect(() => {\\n    fetch(\'https://jsonplaceholder.typicode.com/users\')\\n      .then(response => response.json())\\n      .then(data => setUsers(data));\\n  }, []);\\n\\n  return (\\n    <ul>\\n      {users.map(user => (\\n        <li key={user.id}>{user.name}</li>\\n      ))}\\n    </ul>\\n  );\\n}\\n```\\n\\nIn this example, we are using the `useEffect` hook to fetch data from an API and update the state in a functional component. We initialize the state with an empty array, and we use the `useEffect` hook to perform the fetch operation when the component mounts (i.e., when the array of dependencies is empty). When the fetch operation is complete, we update the state by calling `setUsers` with the fetched data. Finally, we render the list of users by mapping over the `users` array.\\n\\n## Custom Hooks\\n\\nCustom hooks are functions that allow you to reuse stateful logic between components. They are a way to extract common functionality into a reusable module, making your code more modular and easier to maintain. Custom hooks can use built-in hooks or other custom hooks, and can take arguments and return values.\\n\\n```javascrip\\nimport React, { useState, useEffect } from \'react\';\\n\\nfunction useCounter(initialCount) {\\n  const [count, setCount] = useState(initialCount);\\n\\n  useEffect(() => {\\n    const intervalId = setInterval(() => {\\n      setCount(count => count + 1);\\n    }, 1000);\\n\\n    return () => clearInterval(intervalId);\\n  }, []);\\n\\n  return count;\\n}\\n\\nfunction Timer() {\\n  const count = useCounter(0);\\n\\n  return (\\n    <p>You have been on this page for {count} seconds.</p>\\n  );\\n}\\n```\\n\\nIn this example, we are creating a custom hook called `useCounter` that uses the `useState` and `useEffect` hooks to implement a simple counter. The `useCounter` hook takes an `initialCount` argument and returns the current count value, which is updated every second using a `setInterval` function inside the `useEffect` hook. We then use the `useCounter` hook inside the `Timer` component to display the number of seconds the user has been on the page.\\n\\n## Best Practices for Using React Hooks\\n\\nTo get the most out of React Hooks, it\'s important to follow some best practices. These include using the useState hook to manage local state, using the useEffect hook to manage side effects, and creating custom hooks to reuse stateful logic. It\'s also important to avoid using hooks inside loops or conditionals, and to use the array destructuring syntax to name your variables.\\n\\n## Conclusion\\n\\nReact Hooks are a powerful tool for managing state and side effects in your functional components. They allow you to reuse stateful logic between components, making your code more modular and easier to maintain. By following the best practices outlined in this article, you can take advantage of the full power of React Hooks and build better React applications.\\n\\nReact Hooks provide a way to manage state and side effects in functional components, making them more powerful and easier to write. By using the useState and useEffect hooks, creating custom hooks, and following best practices, you can take advantage of the full power of React Hooks and build better React applications. With this knowledge, you\'ll be able to take your front-end development skills to the next level and create more efficient and maintainable code."}]}')}}]);