"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5914],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),d=r,m=p["".concat(l,".").concat(d)]||p[d]||h[d]||i;return n?o.createElement(m,a(a({ref:t},c),{},{components:n})):o.createElement(m,a({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,a[1]=s;for(var u=2;u<i;u++)a[u]=n[u];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5177:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var o=n(7462),r=(n(7294),n(3905));const i={title:"Routing"},a=void 0,s={permalink:"/blog/2023/03/02/router",editUrl:"https://lipingpan101.github.io/blog/2023-03-02-router.md",source:"@site/blog/2023-03-02-router.md",title:"Routing",description:"There are two main types of routing: front-end routing and server-side routing. Front-end routing is handled entirely by the client-side code in the browser, while server-side routing is handled by the server that hosts the website.",date:"2023-03-02T00:00:00.000Z",formattedDate:"March 2, 2023",tags:[],readingTime:5.2,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Routing"},prevItem:{title:"Front End Build Tools",permalink:"/blog/2023/03/02/build-tool"},nextItem:{title:"Git Basics",permalink:"/blog/2023/02/25/git-basics"}},l={authorsImageUrls:[]},u=[{value:"React Router",id:"react-router",level:3},{value:"Questions:",id:"questions",level:3}],c={toc:u},p="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"There are two main types of routing: front-end routing and server-side routing. Front-end routing is handled entirely by the client-side code in the browser, while server-side routing is handled by the server that hosts the website."),(0,r.kt)("p",null,"Front-end routing is typically used in single-page applications (SPAs), where the entire website is loaded once and subsequent page views are handled by JavaScript code running in the browser. This type of routing is implemented using client-side routing libraries like React Router, and it allows for a seamless user experience with fast page transitions and minimal page refreshes. However, since the routing is entirely handled by JavaScript, it's not SEO(Search Engine Optimization)-friendly and can be less performant for initial page loads."),(0,r.kt)("p",null,"On the other hand, server-side routing is used in traditional multi-page applications, where each page is loaded separately from the server. This type of routing is handled by the server-side code, typically using a web framework like Express or Ruby on Rails. Since the server handles the routing, the website can be SEO-friendly and performant for initial page loads. However, subsequent page transitions can be slower due to the need to reload the entire page from the server."),(0,r.kt)("p",null,"In some cases, a hybrid approach is used, called server-side rendering (SSR). In this approach, the server renders the initial HTML content of the website and sends it to the client, which then takes over for subsequent page transitions using client-side routing. This approach provides the best of both worlds, allowing for SEO-friendly initial page loads and seamless client-side routing for subsequent page transitions."),(0,r.kt)("p",null,"Overall, choosing the right type of routing depends on the specific requirements of your website or application. React Router and the Router Hook API provide powerful tools for implementing front-end routing in your React applications, while server-side routing and SSR can be useful for more traditional multi-page applications."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"react-router"},"React Router"),(0,r.kt)("p",null,"React Router is a powerful library that allows you to implement front-end routing in your React applications. It offers a wide range of components and features that make it easy to create single-page applications with multiple routes and views. One of the most useful features of React Router is the Router Hook API, which allows you to interact with the routing system programmatically."),(0,r.kt)("p",null,"The Router Hook API provides a set of hooks that allow you to access the current location, navigate to different routes, and listen for changes to the route. Let's take a look at some of the most useful hooks in the Router Hook API:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"useHistory()"),": This hook returns the history object, which you can use to navigate to different routes programmatically. For example, you can use history.push('/my-route') to navigate to the 'my-route' route."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"useLocation()"),": This hook returns the current location object, which contains information about the current URL. You can use this hook to get the current pathname, search, and hash values."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"useParams()"),": This hook returns an object containing the dynamic parameters in the current URL. For example, if you have a route defined as '/users/:userId', you can use useParams() to get the value of ':userId' in the current URL."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"useRouteMatch()"),": This hook returns an object containing information about the current route match. You can use this hook to get the current path, URL, and params for the matched route.")),(0,r.kt)("p",null,"Using these hooks, you can create custom navigation components, implement authentication and authorization logic, and handle complex routing scenarios. For example, you can use the Router Hook API to redirect users to a login page if they try to access a protected route without authentication."),(0,r.kt)("p",null,"In addition to the Router Hook API, React Router also provides a wide range of components for implementing routing in your application. The most commonly used components include:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"<Router>"),": This component is the top-level component for the routing system. It provides the context and history objects that are used by other routing components."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"<Route>"),": This component is used to define a route in your application. You can specify the path, component, and other options for the route."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"<Link>"),": This component is used to create links between routes in your application. It provides a declarative way to navigate between routes.")),(0,r.kt)("p",null,"Overall, React Router is an essential library for any React developer who wants to implement front-end routing in their applications. With the Router Hook API and other components, you can create powerful routing systems that are flexible and easy to use."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"questions"},"Questions:"),(0,r.kt)("p",null,"Q1. How to implement front-end routing in React without using React Router?"),(0,r.kt)("p",null,"Answer:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Listen for URL changes and retrieve the current URL, which can be done using the browser's provided API: window.location."),(0,r.kt)("li",{parentName:"ol"},"Match the corresponding page or component based on the current URL."),(0,r.kt)("li",{parentName:"ol"},"Render the matched page or component.")),(0,r.kt)("p",null,"Q2. What components need to be defined to implement React Router?\nAnswer:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Router: The router component is the top-level component that holds the entire routing configuration. There are two types of routers you can use: ",(0,r.kt)("inlineCode",{parentName:"li"},"<BrowserRouter>")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"<HashRouter>"),". ",(0,r.kt)("inlineCode",{parentName:"li"},"<BrowserRouter>")," uses the HTML5 History API to manage the URLs, while ",(0,r.kt)("inlineCode",{parentName:"li"},"<HashRouter>")," uses the hash portion of the URL to store the routing information."),(0,r.kt)("li",{parentName:"ol"},"Route Matcher: The route matcher components are used to match the current URL with a specific component that should be rendered. There are several types of route matcher components available, including ",(0,r.kt)("inlineCode",{parentName:"li"},"<Route>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<Switch>"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"<Redirect>"),". ",(0,r.kt)("inlineCode",{parentName:"li"},"<Route>")," is used to specify a particular path and the component that should be rendered when the path matches. ",(0,r.kt)("inlineCode",{parentName:"li"},"<Switch>")," is used to group multiple ",(0,r.kt)("inlineCode",{parentName:"li"},"<Route>")," components and render only the first one that matches the current URL. ",(0,r.kt)("inlineCode",{parentName:"li"},"<Redirect>")," is used to redirect the user to a different URL when a certain path is matched."),(0,r.kt)("li",{parentName:"ol"},"Navigation components: The navigation components are used to create links between the different pages of your application. There are several navigation components available, including ",(0,r.kt)("inlineCode",{parentName:"li"},"<Link>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<NavLink>"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"<RouterLink>"),". ",(0,r.kt)("inlineCode",{parentName:"li"},"<Link>")," is used to create a standard hyperlink that takes the user to a different page. ",(0,r.kt)("inlineCode",{parentName:"li"},"<NavLink>")," is used to create a hyperlink that is styled differently when the current URL matches the link's path. ",(0,r.kt)("inlineCode",{parentName:"li"},"<RouterLink>")," is used to create a hyperlink that is aware of the current routing context and can navigate to a different route within your application.")),(0,r.kt)("p",null,"An example can be found ",(0,r.kt)("a",{parentName:"p",href:"https://www.w3schools.com/react/react_router.asp"},"here"),"."))}h.isMDXComponent=!0}}]);